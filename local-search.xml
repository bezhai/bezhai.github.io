<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android中的广播机制</title>
    <link href="/2020/01/16/Android%E4%B8%AD%E7%9A%84%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/01/16/Android%E4%B8%AD%E7%9A%84%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="广播的分类"><a href="#广播的分类" class="headerlink" title="广播的分类"></a>广播的分类</h2><p>在 Android 中，广播是一种活动和应用程序之间进行信息获取和传递的一种有效手段。广播分为<strong>标准广播</strong>和<strong>有序广播</strong>两种。当然也可以按照注册方式分类为<strong>动态注册</strong>和<strong>静态注册</strong>两种，按照定义的方式可以分为<strong>系统广播</strong>和<strong>自定义广播</strong>。</p><ul><li><p>标准广播</p><p>特点是异步执行，所有的广播接收器会在几乎同时接收到同一条标准广播，没有先后顺序，意味着无法被截断。</p></li><li><p>有序广播</p><p>同步执行，在广播发出之后，同一时刻只有一个广播接收器能够接受广播消息。在广播接收器执行完逻辑之后，广播继续传递。传递的顺序取决于设置的优先级。</p></li></ul><blockquote><p>优先级规则：</p><ol><li>排序规则为：<strong>将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序</strong></li><li>同级别接收是随机的，但是动态注册优先于静态注册</li><li>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改</li></ol></blockquote><h2 id="广播的使用"><a href="#广播的使用" class="headerlink" title="广播的使用"></a>广播的使用</h2><h3 id="动态注册广播接收器"><a href="#动态注册广播接收器" class="headerlink" title="动态注册广播接收器"></a>动态注册广播接收器</h3><ul><li><p>实现</p><p>通过继承 BroadcastReceiver 并重写 onReceive 方法来实现自己的业务逻辑</p><pre><code class="java">public class MyReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        Toast.makeText(context, &quot;I see it&quot;, Toast.LENGTH_SHORT).show();        abortBroadcast();//有序广播中截断广播    }}</code></pre></li><li><p>注册</p><p>在 Activity 注册之后要在 onDestroy 方法取消注册</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    private MyReceiver receiver;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        IntentFilter intentFilter = new IntentFilter(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);        //IntentFilter intentFilter = new IntentFilter();        //intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);        intentFilter.setPriority(100);//设置优先级，如果是有序广播        receiver = new MyReceiver();        registerReceiver(receiver, intentFilter);    }       @Override    protected void onDestroy() {        unregisterReceiver(receiver);        super.onDestroy();    }}</code></pre></li></ul><h3 id="静态注册广播"><a href="#静态注册广播" class="headerlink" title="静态注册广播"></a>静态注册广播</h3><p>动态注册广播依赖于活动，在活动结束之后不能继续监听广播，例如监听开机广播。这时需要注册静态广播：在 AndroidManifest 文件添加相关参数：其中 enabled 表示是否启用，exported 表示是否接受其他应用的广播，priority 为优先级（可选）。另外如本示例监听开机广播之类的需要声明权限。</p><pre><code class="xml">&lt;receiver          android:name=&quot;.MyReceiver&quot;          android:enabled=&quot;true&quot;          android:exported=&quot;true&quot;&gt;          &lt;intent-filter android:priority=&quot;100&quot;&gt;              &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;          &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><h3 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h3><p>发送广播需要构建 Intent 对象，下面将演示标准和有序两种实现</p><pre><code class="java">findViewById(R.id.button_1).setOnClickListener((v -&gt; {    Intent intent = new Intent(&quot;xyz.yuanzhi.broadcasttest.MY_BROADCAST&quot;);    intent.setComponent(new ComponentName(&quot;xyz.yuanzhi.broadcasttest2&quot;,                     &quot;xyz.yuanzhi.broadcasttest2.MyReceiver&quot;));    //如果自定义的广播接收器是静态注册，在 Android8.0 之后需要添加 setComponent 方法    //第一个参数是接收器的包名，第二个是接收器的类名    sendBroadcast(intent);//标准广播    sendOrderedBroadcast(intent, null);//有序广播，第二个参数设置接收者权限        }));</code></pre><h3 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h3><p>顾名思义，本地广播只能被应用程序内部传递，接收器只能接受本程序的广播事件。如果要使用，需要添加库支持(androidx.localbroadcastmanager:localbroadcastmanager)。</p><p>示例代码如下</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    private static String INTENT_STRING = &quot;string&quot;;    private static String MY_BROADCAST = &quot;xyz.yuanzhi.broadcasttest.MY_BROADCAST&quot;;    private BroadcastReceiver receiver;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        receiver = new BroadcastReceiver() {            @Override            public void onReceive(Context context, Intent intent) {                Toast.makeText(context, intent.getStringExtra(MainActivity.INTENT_STRING),                        Toast.LENGTH_LONG).show();            }        };        findViewById(R.id.button_1).setOnClickListener((v-&gt;{            Intent intent = new Intent(MY_BROADCAST);            intent.putExtra(INTENT_STRING, &quot;Look&quot;);            LocalBroadcastManager.getInstance(this).sendBroadcast(intent);        }));        LocalBroadcastManager.getInstance(this).registerReceiver(receiver,                new IntentFilter(MY_BROADCAST));    }    @Override    protected void onDestroy() {        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);        super.onDestroy();    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
