<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2019/12/28/test/"/>
    <url>/2019/12/28/test/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><ul><li>存储器由存储单元组成，每个单元从 0 开始编号</li><li>一个存储单元能存储1 Byte 数据，即8 bit</li></ul><h3 id="CPU读写数据"><a href="#CPU读写数据" class="headerlink" title="CPU读写数据"></a>CPU读写数据</h3><ul><li><p>数据读写交互数据</p><ul><li>存储单元地址（地址信息）</li><li>器件选择，读或写的命令（控制信息）</li><li>读写数据内容（数据信息）</li></ul></li><li><p>总线</p><p>计算机中专门连接CPU和其他芯片的导线</p></li><li><p>读取数据过程</p><ol><li>CPU将地址信息通过地址线发出</li><li>CPU通过控制线发出内存读/写指令，选中存储器芯片，通知其将读取/写入数据</li><li>存储器将规定地址的数据通过数据线送入CPU</li></ol></li><li><p>地址总线</p><ul><li>CPU寻址用线</li><li>CPU的地址线数量N称为地址总线的宽度，可寻找2<sup>N</sup>个内存单元</li></ul></li><li><p>数据总线</p><ul><li>完成CPU与其他器件的数据传输</li><li>8086 CPU数据总线宽度为 16，8088 为 8，即 8088 每次可以传输两个字节的内容</li></ul></li><li><p>控制总线</p><ul><li>反映CPU对外部器件的控制能力</li><li>读信号输出和写信号输出分别由不同的控制线负责</li></ul></li></ul><h3 id="存储器类型"><a href="#存储器类型" class="headerlink" title="存储器类型"></a>存储器类型</h3><ul><li><p>从读写属性区分</p><ul><li><p>随机存储器(RAM)</p><p>可读可写，但必须带电存储，关机后内容丢失</p></li><li><p>只读存储器(ROM)</p><p>只可读不可写，关机后内容不丢失</p></li></ul></li><li><p>从功能区分</p><ul><li><p>随机存储器</p><p>存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由主板上RAM和拓展插槽上的RAM(内存条)组成</p></li><li><p>存储 BIOS 的ROM</p></li><li><p>接口卡上的RAM</p><p>例如显卡的显存</p></li></ul></li></ul><h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><pre><code>     CPU在操纵上述存储器时，都把它们当作内存看待，即一个个存储单元，CPU把这些存储器当作一个总的逻辑存储器，也就是内存地址空间。每个存储器都分配了某一段地址空间，地址空间总大小受CPU地址总线宽度限制。实际编程中，需要知道每个存储器的首地址和末地址。</code></pre><hr><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>​        CPU由运算器、控制器和寄存器等构成，依靠内部总线相连</p><p>​        8086有14个寄存器，包括AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES和PSW</p><ul><li><p>AX、BX、CX和DX</p><ul><li>AX：累加器，使用频度最高，用于算术、逻辑运算以及与外设传送信息等</li><li>BX：基址寄存器，常用做存放存储器地址</li><li>CX：计数器，作为循环和串操作等指令中的隐含计数器；<strong>程序开始时会保存程序结束处偏移地址</strong></li><li>DX：数据寄存器，常用来存放双字长数据的高16位，或存放外设端口地址</li></ul></li><li><p>CS、SS、DS和ES为段寄存器</p><ul><li>CS：代码段寄存器</li><li>DS：读写内存地址寄存器</li><li>SS：栈顶段地址寄存器</li></ul></li><li><p>栈相关寄存器</p><ul><li>SP：堆栈指针寄存器，指示栈顶的偏移地址</li><li>BP：基址指针寄存器，表示数据在堆栈段中的基地址，可以用作遍历指针</li></ul></li><li><p>IP：指令指针寄存器</p></li><li><p>变址寄存器SI、SI</p><p>​    变址寄存器常用于存储器寻址时提供地址，不能拆分成两个8位寄存器。在8086CPU中，只有bx，si，di，bp这4个寄存器可以用在[…]中来进行内存单元的寻址</p><ul><li>SI是源变址寄存器</li><li>DI是目的变址寄存器</li></ul></li></ul><p>比如</p><h2 id="基础汇编指令"><a href="#基础汇编指令" class="headerlink" title="基础汇编指令"></a>基础汇编指令</h2><table><thead><tr><th>汇编指令</th><th>完成的操作</th></tr></thead><tbody><tr><td>mov ax,18</td><td>将18送入寄存器AX</td></tr><tr><td>mov ax,bx</td><td>将BX的数据送入AX</td></tr><tr><td>mov [0],ax</td><td>将AX的数据送入0地址字单元</td></tr><tr><td>add ax,8</td><td>将AX的数据加上8</td></tr><tr><td>add ax,bx</td><td>将AX和BX数值相加，存储在AX中</td></tr><tr><td>sub ax,bx</td><td>将AX减BX的数值存储在AX中</td></tr><tr><td>add ax,[0]</td><td>将0地址字单元的内容数值加上AX，存储在AX中</td></tr><tr><td>inc bx</td><td>add bx,1</td></tr><tr><td>dec bx</td><td>sub bx,1</td></tr></tbody></table><ul><li>汇编指令不区分大小写</li><li>当要存储的结果超过寄存器存储上限，将丢弃高位，例如：对于16位寄存器ax，当值为1044CH时，存储为044CH；对于使用兼容性的8位寄存器al，值为158H时，所在ax的数据保存为0058H(al为0-7位，ah为8-15位)</li><li>注意运算和操作时注意操作对象的位数应是一致的、</li></ul><h2 id="CPU位数含义"><a href="#CPU位数含义" class="headerlink" title="CPU位数含义"></a>CPU位数含义</h2><p>例如8086处理器是16位结构，表示</p><ul><li>字长是16位</li><li>运算器一次最多处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间通路为16位</li><li>暂存地址位数为16位</li></ul><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>​        每个内存单元在内存空间的唯一地址，称为物理地址；8086处理器有20位地址总线，需要两个16位地址合成为一个20位的物理地址</p><p>当CPU读写内存时</p><ol><li>CPU提供两个16位地址，一个成为段地址，另一个为偏移地址</li><li>两个地址通过内部总线送入地址加法器</li><li>采用<strong>物理地址=段地址×16+偏移地址</strong>的方法合成一个20位的物理地址</li><li>地址加法器输出物理地址</li></ol><h2 id="寄存器CS和IP"><a href="#寄存器CS和IP" class="headerlink" title="寄存器CS和IP"></a>寄存器CS和IP</h2><blockquote><p>CS为代码段寄存器，IP为指令指针寄存器</p></blockquote><p>​        在8086中，任意时刻，设CS中内容为M，IP中内容为N，CPU则从内存M×16+N单元开始读取一条指令执行。读取后，IP的值自动增加，增加值由上一条指令长度决定，待执行完指令后继续读取</p><p>​        对8086CPU，加电启动或者复位时，CS=FFFFH，IP=0000H，即FFFF0H单元的指令是8086PC开机后执行的第一条指令</p><p>​        要修改CS和IP的内容，使用“jmp CS:IP”的指令，如：</p><pre><code class="assembly">    jmp 2AE3:3    执行后：CS=2AE3H，IP=0003H    jmp ax    执行前：CS=2AE3H，IP=0003H，ax=1000H    执行后：CS=2AE3H，IP=1000H，ax=1000H</code></pre><h2 id="代码段和数据段"><a href="#代码段和数据段" class="headerlink" title="代码段和数据段"></a>代码段和数据段</h2><p>​        将一组长度为N(N&lt;=64KB)的代码存在一组地址连续、起始地址为16的倍数的内存单元中，称为一个代码段。需要将CS:IP指向代码段的首地址执行</p><p>​        同样的，将一组长度为N(N&lt;=64KB)、一组地址连续且起始地址为16的倍数的内存单元当作存储数据的内存空间，就定义了一个数据段</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li>R：查看、改变寄存器的内容<ul><li>r ax    修改某个寄存器的内容</li></ul></li><li>D：查看内存的内容<ul><li>d 1000:6    查看从1000:6开始的128个内存单元的内容</li><li>d ds:0 18    根据段寄存器的段地址查看:0~:18内存空间的内容</li></ul></li><li>E：改写内存内容<ul><li>e 1000:0 1 ‘p’ 80 “abc” 3    把1000:0-1000:6修改为01 70 80 61 62 63 03</li><li>e 1000:0    从1000:0开始逐个修改内存内容。“.”前面为内存单元原始内容，在后面修改内容，空格进入下一个单元；直接空格表示不修改；回车键结束</li></ul></li><li>U：对机器代码反汇编显示<ul><li>u 1000:6    查看从1000:6开始的汇编指令</li></ul></li><li>T：执行汇编程序，单步跟踪。基本格式T [=地址] [指令数]，如果忽略“地址”的话，T命令从CS:IP处开始运行。“指令数”是要单步执行的指令的数量d </li><li>A：按汇编指令的格式在内存中写入一条机器指令e 1000:<ul><li>a 1000:6    从1000:6开始输入汇编指令</li><li>需要注意，如果上一条指令是修改栈段寄存器SS的指令，那么下一条指令也会紧接执行，如mov ss,ax</li></ul></li><li>P：使用方式同T，但是P命令不会跟踪进入子程序或软中断</li><li>G：执行汇编指令，基本语法为g [=起始地址]  [断点地址]<ul><li>G=10  20，从地址CS:10开始，一直运行到CS:20停止</li><li>G 8，在cs:8设置断点，执行之前的指令</li><li>不设置断点将运行到中止指令才停止</li></ul></li><li>H：计算两个十六进制数的和与差，如H 10 1，结果前一个数是和，后一个是差</li><li>F：使用指定的值填充指定内存区域中的地址，基本语法为F [范围] [填充列表]，如F 1AF5:100 13F 41 42 43表示用字节序列41、42、43轮流填充从1AF5:100开始一直到1AF5:13F的内存区域</li><li>M：将指定内存区域的数据复制到指定的地址，基本语法为M [范围] [指定地址]，如M 1AF5:100 13F 1AF5:140</li><li>C：将两块内存的内容进行比较，基本语法为C [范围] [指定地址]，如C 1AF5:100 13F 1AF5:140，列出不同的内容</li><li>S：在指定的内存区域中搜索指定的串，基本语法为S [范围] [指定串]，搜索该区域是否存在目标字节串，并将搜索结果一一列出</li><li>Q：退出debug，返回DOS</li></ul><h2 id="字和字节"><a href="#字和字节" class="headerlink" title="字和字节"></a>字和字节</h2><p>​        8086CPU中，使用16位寄存器存储一个字，高8位存放高位字节，低8位存放低位字节。将起始地址为N的自单元简称为N地址字单元，例如2:12H，3:2AH，则2地址字单元存放的字型数据为2A12H，2地址单元存放的字节型数据为12H</p><h2 id="DS寄存器"><a href="#DS寄存器" class="headerlink" title="DS寄存器"></a>DS寄存器</h2><p>​        下面这段指令将1000:0中的数据读到al中</p><pre><code class="assembly">mov bx,1000Hmov ds,bxmov al,[0]</code></pre><p>​        不能直接把1000H读入ds中，因为mov ds,1000H是非法的，但是可以把内存单元读入ds，如mov ds,[0]</p><p>​        如果需要将al的数据送入内存单元，可以写成 mov [0],al</p><p>​        如果写成mov [2],ax，说明将ax的值送入2地址字单元</p><p>​        事实上，上面的mov指令，从(段)寄存器(内存单元)都可以相互传送；但是<code>add ds</code>这类操作是不允许的</p><blockquote><p>​    在实际编写程序时，不能写成mov al,[0]，编译器会将其看作mov al,0。这是因为masm将[idata]解释为“idata”(idata表示常量)，我们需要写成mov al,cs:[0]或者使用[bx] (之后会提到)</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>​        栈遵循LIFO的操作规则。在8086CPU中，可以将一段内存当作栈使用。显然，push表示入栈，pop表示出栈(操作对象可以是寄存器、段寄存器或者内存单元)。在8086中，这些操作都是以字单位进行。任意时刻，SS:SP指向栈顶元素。值得注意的是，<strong>入栈时栈顶从高地址向低地址增长</strong></p><p>​        8086CPU不保证栈操作不会越界，因为它只知道栈顶所在位置而不知道栈空间大小。所以要求我们自己注意这一问题，自己管理栈空间的大小</p><p>​        与数据段代码段类似，我们可以定义一个栈段。当然这只是编程时的一种安排，CPU本身并不会自动将栈段当作栈空间使用，我们需要自行管理。64KB的限制是因为栈操作只修改SP地址，偏移地址最多可以表示64KB的地址信息，同理可以解释其他类型段的问题</p><p>​        所以如果将10000H~1FFFFH这段空间当作栈段，初始状态栈为空时，SS=1000H，SP=0000H</p><hr><h1 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h1><h2 id="编写汇编程序的流程"><a href="#编写汇编程序的流程" class="headerlink" title="编写汇编程序的流程"></a>编写汇编程序的流程</h2><pre><code class="mermaid">graph LRid(源程序) --编译--&gt; id2(目标文件) id2 --连接--&gt; id3(可执行文件)id3 --- id4(程序和数据)id3 --- id5(描述信息)</code></pre><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><p>下面是一段汇编语言源程序</p><pre><code class="assembly">assume cs:codesgcodesg segment        mov ax,0123        mov bx,0456        add ax,bx        add ax,ax        mov ax,4c00        int 21codesg endsend</code></pre><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>​        伪指令没有对应的机器指令，不被CPU执行，而是由编译器处理</p><ul><li>segment&amp;ends</li></ul><pre><code class="assembly">xxx segment    :    :xxx ends</code></pre><p>​        这对指令的功能是定义一个段，每个段必须有一个名称标识</p><ul><li><p>end</p><p>end是一个汇编程序<strong>必需</strong>的结束标记，且之后的内容不再编译</p></li><li><p>assume</p><p>它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联，通过assume说明这一关联。</p></li></ul><h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>​        如codesg这种的称为标号，它指代了一个地址</p><h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><p>​        对于DOS(一种单任务操作系统)而言，有一个程序command.com，称为命令解释器，即DOS系统的shell。DOS启动时，完成其他重要的初始化工作后，运行command.com，执行完剩下任务后，在屏幕上显示提示符，如“C:\”等，等待用户输入</p><p>​        要执行程序p，command.com首先根据文件名找到可执行文件，将p加载进内存：找到一段起始地址为SA:0000的容量足够的空闲内存区，在前256个字节创建程序段前缀(PSP)来和被加载程序进行通信，在其后面(SA+10H:0)载入程序，<strong>设置DS=SA</strong>，<strong>设置CS:IP指向程序入口</strong>，即将CPU的控制权交给p；p运行结束后，需要进行<strong>程序返回</strong>来把CPU的控制权交还给command.com，这就需要添加必要的程序指令，例如</p><pre><code class="assembly">mov ax,4c00int 21</code></pre><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>​        如同[0]可以表示偏移地址为0的内存单元，[bx]同样也表示一个内存单元，例如下面的指令</p><pre><code class="assembly">mov ax,[bx]mov ax,[bx+5]</code></pre><p>​        bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。mov [ax],bx也是允许的，表示为((ds)*16+(bx))=(ax)</p><p>​        而[bx+5]表示偏移地址是(bx)+5，等价于[5+ax]、5[ax]、[ax].5</p><blockquote><p>​        (ds)表示存放在ds中的数据，以此类推；注意，(20000H)是正确的，但(2000：0)是不符合约定的</p></blockquote><h3 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h3><p>​        格式：loop codesg</p><p>​        执行：当执行loop指令时</p><pre><code class="mermaid">graph LRstart[Loop x]--&gt;calculate[cx--]calculate--&gt;condition{cx==0?}condition--YES--&gt;branch1[向下执行]condition--NO--&gt;branch2[跳转到x处执行]</code></pre><p>​        cx就是cx寄存器的内容，我们在使用loop指令时，依靠cx存放循环次数</p><p>​        示例：编程计算2^10^</p><pre><code class="assembly">assume cs:codecode segment        mov ax,2        mov cx,9    s:    add ax,ax        loop s        mov ax,4c00H        int 21H        code endsend</code></pre><h3 id="安全使用内存"><a href="#安全使用内存" class="headerlink" title="安全使用内存"></a>安全使用内存</h3><p>​        如果需要直接向内存写入内容，那么可以使用0:200~0:2ff这段空间</p><h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>​        访问内存的段地址默认是ds，也可以利用cs:[bx]的形式显式地给出内存地址，这时cs称为段前缀。有时需要频繁更换内存单元段地址时，可以使用额外的段寄存器es。例如将ffff:0 ~ ffff:b单元的数据复制到0:200 ~ 0:20b中，通常需要来回切换ds的值。但是利用es段前缀则不需要</p><pre><code class="assembly">mov dl,[bx]mov es:[bx],dl</code></pre><h3 id="汇编指令字节数"><a href="#汇编指令字节数" class="headerlink" title="汇编指令字节数"></a>汇编指令字节数</h3><ol><li>mov ax,2000    3字节</li><li>mov ds,ax         2字节</li><li>mov [bx],bx      2字节</li><li>inc bx                1字节</li><li>loop s                1字节</li><li>int 21H              2字节</li></ol><h3 id="分配内存空间"><a href="#分配内存空间" class="headerlink" title="分配内存空间"></a>分配内存空间</h3><h4 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h4><pre><code class="assembly">assume cs:codecode segment        dw 0123H,2635H,36a2Hstart:    mov bx,2        mov ax,0        mov cx,3    s:    add ax,cs:[bx]        add bx,2        loop s        mov ax,4c00H        int 21H        code endsend start</code></pre><p>​        上面是一个定义字型数据的样例，它们位于CS:0、CS:2、CS:4中，也就是说它们位于代码段的最开始。由于一般程序开始执行时，IP=0，会把字型数据当作机器码，导致程序出现问题。所以需要将程序入口处设置到mov bx,2处，所以我们使用start标记程序开始处，使用end start结束程序</p><h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><pre><code class="assembly">dw 0,0,0,0</code></pre><p>​        用dw定义若干个字型数据，程序加载时，让栈寄存器指向该地址，具体方法参见之前内容</p><h4 id="多段编程"><a href="#多段编程" class="headerlink" title="多段编程"></a>多段编程</h4><p>​        很明显，如果能将数据、栈和代码分离，就很方便管理。于是我们可以定义多个段，例如</p><pre><code class="assembly">assume cs:code,ds:data,ss:stackdata segment    dw 0123h,0631h,52c3hdata endsstack segment    dw 0,0,0,0,0stack endscode segmentstart:  mov ax,stack        mov ss,ax        mov sp,8h        mov ax,data        mov ds,ax        mov bx,0        mov cx,3    s:  push [bx]        add bx,2        loop segment        mov bx,0        mov cx,3    s0: pop [bx]        add bx,2        loop s0        mov ax,4c00H        int 21Hcode endsend start</code></pre><p>​        很明显，想要访问某一段的数据，可以使用mov ax,stack的形式。不过要注意这时stack表示的是stack段的段地址，是一个数值，所以不能写成mov ds,data的形式</p><h4 id="存储字符类型数据"><a href="#存储字符类型数据" class="headerlink" title="存储字符类型数据"></a>存储字符类型数据</h4><p>​        前面我们使用dw存储字型类型数据，我们也可以使用db的形式存储，例如db ‘pd056+’</p><p>​        在程序中，‘a’与61H等价，例如mov al,‘a’</p><h3 id="与非"><a href="#与非" class="headerlink" title="与非"></a>与非</h3><ul><li>and：按位逻辑与，使用方式and ax,00100000B</li><li>or：按位逻辑或，使用方式and ax,00100000B</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
